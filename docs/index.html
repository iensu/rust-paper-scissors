<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-12-09 Thu 13:26 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust, Paper, Scissors</title>
<meta name="author" content="Jens Östlund" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="style-overrides.css" />
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Rust, Paper, Scissors</h1>
</header><p>
<i>This text is an outline for a hands-on Rust workshop for beginners held at <a href="https://futurice.com/">Futurice</a>. The content is geared towards developers with a background in more dynamic languages such as JavaScript or Python but who has no prior experience coding in Rust.</i>
</p>

<p>
Let's learn a bit of Rust through a game of ✊✋✌️! We will be implementing a CLI app for playing rock, paper, scissors.
</p>

<p>
A quick reminder of the rules of the game:
</p>

<ul class="org-ul">
<li>Each player selects either rock, paper or scissors</li>
<li>Players reveal their pick at the same time</li>
<li>The winner is decided according to the following rules:
<ul class="org-ul">
<li>Rock beats scissors</li>
<li>Scissors beat paper</li>
<li>Paper beats rock</li>
</ul></li>
</ul>

<p>
Usually the game is played best of three rounds and can include multiple people. For the sake of time we will only consider a two player game (human vs. computer) of 1 round.
</p>

<p>
By following the instructions and tackling the exercises below you will should get a feel for the Rust workflow and the language itself.
</p>

<p>
To follow along you will need to have <code>cargo</code>, the build tool, and <code>rustc,</code> the Rust compiler, installed. I've used <code>rustc</code> version 1.57.0 when writing article. I recommend using using <a href="https://rustup.rs/">rustup</a> if you need to install them.
</p>

<p>
There is <a href="https://github.com/iensu/janken/">a reference repository</a> which follows the article. If you get stuck at one of the exercises you can have a look at the commit history of the project to get inspiration on how to move forward.
</p>

<p>
As the article progresses more assumptions will be made about the code you have written. For instance, I make the assumption that you will write code that follows idiomatic JavaScript or Python patterns and will introduce rustier ways of doing things as we go along. The reason being that I want you to solve the exercise yourself first and keep blind code copying to a minimum. If your solution starts to diverge and you end up at a place where my instructions do not make sense, most likely you've thought ahead so move on to the next step.
</p>

<div id="outline-container-org2f81885" class="outline-2">
<h2 id="org2f81885"><span class="section-number-2">1.</span> Humble beginnings</h2>
<div class="outline-text-2" id="text-1">
<p>
We need to create a project for our app, but before that we need a name. Let's call it <i>janken</i> (じゃん拳), the Japanese name for the game. You can create your project using <code>cargo</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cargo new janken
</pre>
</div>

<p>
This will create a project with a very simple Rust application (binary) with only one source file: <code>./src/main.rs</code> and a <code>Cargo.toml</code> project manifest file. Git has also already been setup for you.
</p>

<p>
You can run your application like so:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cargo run
</pre>
</div>

<p>
That command will compile your application and run it. The actual application binary has been written to <code>./target/debug/janken</code>. Now try this:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ ./target/debug/janken
</pre>
</div>

<p>
Rust compiles your application down to machine code so you can execute the binary directly; there is no need for an external program to execute it like for example with Node.js or Python.
</p>

<p>
We need to be able to decide who the winner is so let's create a function that takes two hand shapes and returns <code>true</code> if the first argument is the winner, <code>false</code> otherwise. Since we're still a bit away from being able to test the logic ourselves, let's start with writing some tests.
</p>
</div>

<div id="outline-container-org7357620" class="outline-3">
<h3 id="org7357620"><span class="section-number-3">1.1.</span> Writing tests</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In Rust we usually tests write tests in a private module in the same file (<b>module</b>) as the implementation.
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">This annotation makes sure the `tests` module is</span>
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">only compiled when running tests.</span>
<span style="color: #ff9077;">#[cfg(test)]</span>
<span style="color: #b6a0ff;">mod</span> <span style="color: #00bcff;">tests</span> {
    <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">We import everything in our parent module.</span>
    <span style="color: #b6a0ff;">use</span> <span style="color: #b6a0ff;">super</span>::*;

    <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">This annotation tells the test runner that the</span>
    <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">function should be run as a test.</span>
    <span style="color: #ff9077;">#[test]</span>
    <span style="color: #b6a0ff;">fn</span> <span style="color: #feacd0;">is_meaning_of_life</span>() {
        <span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">meaning_of_life</span> = 42;

        <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Make the assertion.</span>
        <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">It is customary to put the expected result on</span>
        <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">the left and the calculated value on the right.</span>
        <span style="color: #ff9077;">assert_eq!</span>(42, meaning_of_life);
    }
}
</pre>
</div>

<p>
<b>EXERCISE 1:</b> Add a test called <code>rock-wins-over-scissors</code> that calls a function called <code>is_winner</code> with the arguments <code>"rock"</code> and <code>"scissors"</code> and expect the result to be <code>true</code>.
</p>
</div>
</div>

<div id="outline-container-orgca05f98" class="outline-3">
<h3 id="orgca05f98"><span class="section-number-3">1.2.</span> Partial implementations</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Now when you try to run the tests the code will not compile since the <code>is_winner</code> function has not yet been defined. Often you will want to try things out before you've figured out all the details of your implementation and made the code compile. Rust has a neat feature for this: the <code>todo!()</code> macro. The <code>todo!()</code> macro will allow your code to compile without you having finished the implementation.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">fn</span> <span style="color: #feacd0;">is_winner</span>(<span style="color: #00d3d0;">p1</span>: &amp;<span style="color: #6ae4b9;">str</span>, <span style="color: #00d3d0;">p2</span>: &amp;<span style="color: #6ae4b9;">str</span>) -&gt; <span style="color: #6ae4b9;">bool</span> {
    <span style="color: #ff9077;">todo!</span>()
}
</pre>
</div>

<p>
Now we are able to run the test, but it fails with the message <i>not yet implemented</i>.
</p>

<p>
<b>EXERCISE 2:</b> Make the test pass and a test case for when <code>is_winner</code> should return <code>false</code>.
</p>

<p>
<b>EXERCISE 3:</b> Follow the same procedure and implement the remaining two cases.
</p>
</div>
</div>
</div>

<div id="outline-container-org7ba4b27" class="outline-2">
<h2 id="org7ba4b27"><span class="section-number-2">2.</span> Rustifying the code</h2>
<div class="outline-text-2" id="text-2">
<p>
There are multiple issues with our <code>is_winner</code> function, for one it does not handle draws yet (we will address that later).
</p>

<p>
Another issue is that the current implementation does not properly codify the domain: we are just matching on plain strings everywhere. Since we know we can only have three different hand shape values, we should express that in the code. In Rust this is done with an <code>enum</code>. You can <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=enum#the-option-enum-and-its-advantages-over-null-values">read more about them here</a>.
</p>
</div>

<div id="outline-container-org8fe7808" class="outline-3">
<h3 id="org8fe7808"><span class="section-number-3">2.1.</span> Our first enum</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>EXERCISE 4</b>: Implement an <code>enum</code> called <code>HandShape</code> for all the hand shapes.
</p>

<p>
When you try to replace the strings with your new, fancy <code>HandShape</code> <code>enum</code> you'll notice that it won't compile. The reason is that the compiler doesn't know how to do comparisons between <code>HandShape</code> instances; nowhere have we told it how we want equality comparisons to work. Fortunately we do not have to write code for this ourselves.
</p>
</div>
</div>

<div id="outline-container-org083331a" class="outline-3">
<h3 id="org083331a"><span class="section-number-3">2.2.</span> Derivable traits and the derive macro</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Traits define a behavior contract that a type can adhere to, very similar to interfaces in other languages. Often you have to provide an implementation for the functions that a trait specifies, but some traits are <b>derivable</b>, that means that the Rust compiler can automatically generate the necessary code for us instead! Common derivable traits are <code>PartialEq</code> for equality comparisons and <code>Debug</code> for printing the type.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ff9077;">#[derive(PartialEq, Debug)]</span>
<span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">HandShape</span> {
    <span style="color: #6ae4b9;">Rock</span>,
    <span style="color: #6ae4b9;">Paper</span>,
    <span style="color: #6ae4b9;">Scissors</span>,
}

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Now we can compare: HandShape::Rock != HandShape::Scissors</span>
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">And log our HandShape: println!("{:?}", HandShape::Rock);</span>
</pre>
</div>

<p>
<b>EXERCISE 5:</b> Make your <code>HandShape</code> enum derive <code>PartialEq</code> and <code>Debug</code>.
</p>
</div>
</div>

<div id="outline-container-org3b9149e" class="outline-3">
<h3 id="org3b9149e"><span class="section-number-3">2.3.</span> Pattern matching</h3>
<div class="outline-text-3" id="text-2-3">
<p>
One of the most useful features of Rust is its pattern matching capabilities, it's like a <code>switch</code> on steroids which not only helps you avoid complicated <code>if</code> chains, but also checks for exhaustiveness making sure you handle all of the possible scenarios.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">foo</span> = 666;

<span style="color: #b6a0ff;">match</span> foo {
    666 =&gt; <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"The beast!"</span>),
    665 =&gt; <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"The neighbor of the beast!"</span>),
    _ =&gt; <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Not the beast..."</span>),
}
</pre>
</div>

<p>
<b>EXERCISE 6</b>: Replace your implementation with a match clause (Hint: you can build ad-hoc tuples: <code>(x, y)</code>).
</p>

<p>
All tests should be passing now, yay!
</p>
</div>
</div>

<div id="outline-container-orgfda9cdb" class="outline-3">
<h3 id="orgfda9cdb"><span class="section-number-3">2.4.</span> What about draws?</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Currently our <code>is_winner</code> function only returns a <code>bool</code>. There's no way for us to indicate a draw! Let's use an enum to encapsulate the three different possible round results.
</p>

<p>
<b>EXERCISE 7:</b> Implement a <code>RoundResult</code> enum which captures the three possible states: win, loss or draw.
</p>

<p>
<b>EXERCISE 8:</b> Add tests for the draw cases and then add the draw handling functionality to the <code>is_winner</code> function.
</p>
</div>
</div>

<div id="outline-container-org7c90c6b" class="outline-3">
<h3 id="org7c90c6b"><span class="section-number-3">2.5.</span> A little refactoring&#x2026;</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Now that we have our logic down we are ready to move on to focusing on interacting with the outside world. However, before we go there we need just a little bit of clean-up.
</p>

<p>
The name <code>is_winner</code> made sense when all we did was return a <code>bool</code>. Now that we are returning a <code>RoundResult</code> we should revisit the name to make our code a bit clearer. Let's rename it to <code>execute_round</code> and add a doc string to explain that result is from the perspective of the left-hand argument.
</p>

<p>
<b>EXERCISE 9:</b> Rename <code>is_winner</code> to <code>execute_round</code> and add a doc string to it (using <code>///</code>).
</p>

<p>
Our main.rs file is getting a bit long as well. Ideally we want the main.rs file to short and only focus on running the application. Let's create a new file: lib.rs and move all our game logic there.
</p>

<p>
<b>EXERCISE 10:</b> Move everything except the <code>main</code> function into a file called <i>lib.rs</i>.
</p>

<p>
If you run the tests again now you will see a bunch of warnings about dead code and things not being used. This is because lib.rs is a separate module from main.rs which is our entrypoint to the application. All of our functions and enums currently live in lib.rs and since everything is <b>private by default</b> in Rust, no-one is able to use them. Let's fix that by marking the functions with <code>pub</code> and thus make them publicly exposed.
</p>

<p>
<b>EXERCISE 11:</b> Make the functions and enums in lib.rs public.
</p>

<p>
When you run the tests now you'll notice that not only did the warnings disappear, we've gotten an additional paragraph for Doc-tests in the output, what's up with that?
</p>
</div>
</div>

<div id="outline-container-orgea9ed50" class="outline-3">
<h3 id="orgea9ed50"><span class="section-number-3">2.6.</span> Documentation</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Another great feature of Rust is the focus on documentation: Cargo comes with built-in documentation capabilities. All comments starting with <code>///</code> are so-called doc strings and can be extracted into a standardized documentation website by running:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cargo doc --open
</pre>
</div>

<p>
Doc strings are written in markdown and support adding code examples as in regular markdown. Code examples in doc strings for public functions will be executed when running <code>cargo test</code> which is great since it ensures the examples compile and are up-to-date. Now, let's add a simple doc test for <code>execute_round</code>.
</p>

<p>
<b>EXERCISE 12</b>: Add a doc test for <code>execute_round</code>. (Hint: you can import your functions and enums with <code>use janken::*;.</code>)
</p>
</div>
</div>
</div>

<div id="outline-container-orga9fc83a" class="outline-2">
<h2 id="orga9fc83a"><span class="section-number-2">3.</span> Interacting with the outside world</h2>
<div class="outline-text-2" id="text-3">
<p>
Let's shift our focus back to main.rs and turn our game logic into an actual game.
</p>
</div>

<div id="outline-container-org86265f5" class="outline-3">
<h3 id="org86265f5"><span class="section-number-3">3.1.</span> Reading input from stdin</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Reading from stdin looks a little bit different than in Node.js or Python in that you first allocate a buffer string to populate:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Prepare a buffer to write the data into</span>
<span style="color: #b6a0ff;">let</span> <span style="color: #b6a0ff;">mut</span> <span style="color: #00d3d0;">buffer</span> = <span style="color: #6ae4b9;">String</span>::new();
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Get a handle to stdin</span>
<span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">stdin</span> = <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">io</span>::stdin();

<span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Write something:"</span>);

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Read a line</span>
stdin.read_line(&amp;<span style="color: #b6a0ff;">mut</span> buffer).unwrap();

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Print the result</span>
<span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"You wrote: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, buffer);
</pre>
</div>

<p>
<b>EXERCISE 13</b>: Add the code above to your <code>main</code> function and run it with <code>cargo run</code>.
</p>

<p>
In Rust everything is immutable by default, that is: once you set a variable you can't modify its value. In order to allow modification of a variable you have to declare it as mutable with the <code>mut</code> keyword.
</p>

<p>
If you have sharp eyes you might have noticed something else that stand out in the code above: what is that <code>unwrap()</code> call doing?
</p>
</div>
</div>

<div id="outline-container-orga6a5420" class="outline-3">
<h3 id="orga6a5420"><span class="section-number-3">3.2.</span> Error handling in Rust</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Let's remove the <code>unwrap()</code> call and run our application again!
</p>

<p>
<b>EXERCISE 14</b>: Remove the <code>unwrap()</code> call and run <code>cargo check</code>.
</p>

<div class="org-src-container">
<pre class="src src-shell">warning: unused <span style="color: #f78fe7;">`Result`</span> that must be used
 --&gt; src/main.rs:9:5
  |
9 |     stdin.read_line(&amp;mut buffer);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: <span style="color: #f78fe7;">`#[warn(unused_must_use)]`</span> on by default
  = note: this <span style="color: #f78fe7;">`Result`</span> may be an <span style="color: #f78fe7;">`Err`</span> variant, which should be handled
</pre>
</div>

<p>
Things can fail, especially when you're interacting with the outside world you don't know who and what you can trust. In Rust things that can fail are encapsulated in a <code>Result&lt;T, E&gt;</code> enum type which has two members <code>Ok(T)</code> and <code>Err(E)</code>. <code>T</code> and <code>E</code> are generic type parameters and are placeholders for any type; this is called generics and works on the surface similarly to generics in TypeScript.
</p>

<p>
If you look at the type signature of <code>stdin.readline()</code> you will see that it has a return type of <code>std::io::Result&lt;usize&gt;</code>. That means that it will either return a <code>Ok(usize)</code> with the number of bytes read, or an <code>Err(std::io::Error)</code>. <code>usize</code> is one of Rust's many numeric types and represents the unsigned default integer size for your computer (most likely 64 bit or 32 bit).
</p>

<p>
By using <code>unwrap()</code> we discardi the error handling and blindly trust the operation will succeed. This is not great since if the operation fails we're not giving the user, or us for that matter, any relevant information about what failed. We can do better!
</p>

<p>
Since it's an enum we can treat it like we did our other enums: <code>match</code>!
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">match</span> stdin.read_line(&amp;<span style="color: #b6a0ff;">mut</span> buffer) {
    <span style="color: #6ae4b9;">Ok</span>(_) =&gt; {
        <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"You wrote: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, buffer);
    }
    <span style="color: #6ae4b9;">Err</span>(err) =&gt; {
        <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Failed to read user input! </span><span style="color: #79a8ff; font-style: italic;">{:?}</span><span style="color: #79a8ff;">"</span>, err);
    }
}
</pre>
</div>

<p>
The above pattern quickly becomes unwieldy and if we don't want to deal with the underlying error can use <code>expect</code> instead which allows us to provide a message if the operation fails:
</p>

<div class="org-src-container">
<pre class="src src-rust">stdin
    .read_line(&amp;<span style="color: #b6a0ff;">mut</span> buffer)
    .expect(<span style="color: #79a8ff;">"Failed to read from stdin"</span>);
</pre>
</div>

<p>
The most idiomatic way however, and the one that combines brevity with explicitness is the <code>?</code> operator. By appending the <code>?</code> operator to a function call the call will either return the value inside the <code>Ok</code> type, or abort the parent function returning the error. This means we have to do a few changes to our <code>main</code> function:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">fn</span> <span style="color: #feacd0;">main</span>() -&gt; <span style="color: #6ae4b9;">Result</span>&lt;(), <span style="color: #00bcff;">io</span>::<span style="color: #6ae4b9;">Error</span>&gt; {
    <span style="color: #b6a0ff;">let</span> <span style="color: #b6a0ff;">mut</span> <span style="color: #00d3d0;">buffer</span> = <span style="color: #6ae4b9;">String</span>::new();
    <span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">stdin</span> = <span style="color: #00bcff;">io</span>::stdin();

    <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Write something:"</span>);

    stdin.read_line(&amp;<span style="color: #b6a0ff;">mut</span> buffer)<span style="color: #f78fe7; font-weight: bold;">?</span>;

    <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"You wrote: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, buffer);

    <span style="color: #6ae4b9;">Ok</span>(())
}
</pre>
</div>

<p>
<b>EXERCISE 15:</b> Add error handling using the <code>?</code> operator.
</p>

<p>
We've changed the return type to be a result of either <code>Ok(())</code>, where <code>()</code> is void (similar here to <code>undefined</code> in JavaScript), or <code>Err(io::Error)</code>. Now we can happily add the <code>?</code> operator to the <code>read_line</code> call as long as we remember to return a result as well.
</p>

<p>
There are more sophisticated ways to handle errors, but this is good enough for now!
</p>
</div>
</div>

<div id="outline-container-orgb6867d6" class="outline-3">
<h3 id="orgb6867d6"><span class="section-number-3">3.3.</span> Turning user input into HandShape</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Before we can call our <code>execute_round</code> function we need to take the user input and convert it into a <code>HandShape</code>. Let's implement a function <code>to_handshape(s: String) -&gt; Result&lt;HandShape, String&gt;</code> (we'll use <code>String</code> as the error type) which can turn the user input into a <code>HandShape</code>.
</p>

<p>
<b>EXERCISE 16</b>: Implement <code>to_handshape</code> as described above.
</p>
</div>

<div id="outline-container-org488ecc2" class="outline-4">
<h4 id="org488ecc2">The TryFrom trait</h4>
<div class="outline-text-4" id="text-org488ecc2">
<p>
While the above approach works in Rust we often rely on methods like <code>from()</code>, <code>into()</code>, <code>try_from()</code> and <code>try_into()</code> to convert between types. You can add these methods to your type by implementing the traits <code>From&lt;T&gt;</code> and <code>TryFrom&lt;T&gt;</code>. In our case we'll need the <code>TryFrom</code> trait since we cannot turn every possible user input into a <code>HandShape</code>.
</p>

<p>
<b>EXERCISE 17</b>: Implement <code>TryFrom&lt;String&gt;</code> for <code>HandShape</code> and replace the call to <code>to_handshape</code> with <code>HandShape::try_from(buffer)</code>.
</p>
</div>
</div>

<div id="outline-container-org7c6ce69" class="outline-4">
<h4 id="org7c6ce69">String and &amp;str</h4>
<div class="outline-text-4" id="text-org7c6ce69">
<p>
One thing you quickly stumble upon in Rust is the fact that it has two types of strings: <code>String</code> and <code>&amp;str</code>. <code>String</code> is a mutable, heap allocated buffer. That is, you can modify it in place, grow it or shrink it. <code>str</code>, on the other hand, is called a <i>string slice</i> and is an immutable view of a contiguous sequence of UTF-8 bytes in memory. You almost always encounter <code>str</code> as a reference: <code>&amp;str</code>. <a href="https://blog.thoughtram.io/string-vs-str-in-rust/">This blog post</a> explains the difference in detail. We will briefly touch upon what a reference is when we go into ownership and borrowing.
</p>

<p>
In short, in-line strings in your code will always be of type <code>&amp;str</code> unless you explicitly turn them into <code>String</code>:s. As a beginner <code>String</code>:s are a bit easier to work with since you don't have to think about ownership and lifetimes as much.
</p>
</div>
</div>
</div>

<div id="outline-container-org95ac5d8" class="outline-3">
<h3 id="org95ac5d8"><span class="section-number-3">3.4.</span> Our game loop</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Now we should have all the pieces we need to start implementing our actual game loop. There are many ways to loop in Rust:
</p>

<ul class="org-ul">
<li><code>loop</code> is for infinite loops (which you can <code>break</code> out of)</li>
<li><code>while</code> for looping until a predicate is false</li>
<li><code>for</code> is for iterating over a iterator until it is empty</li>
</ul>

<p>
<b>EXERCISE 18:</b> Implement a game loop which loops until the player either wins or loses.
</p>

<p>
For now you can hard-code the computer's choice, we'll look into handling the computer player soon.
</p>

<p>
At this point you most likely have had the compiler, at one time or another, kindly tell you that you are using a value after it has been moved. Let's dig a little deeper into what that actually means and what we can do to resolve that kind of error.
</p>
</div>

<div id="outline-container-org0cb5861" class="outline-4">
<h4 id="org0cb5861">Ownership and borrowing</h4>
<div class="outline-text-4" id="text-org0cb5861">
<p>
Rust has an memory model based on ownership, it helps us with variable allocation and deallocation and makes sure we're not trying to access or use a variable that has been deallocated, a so called null pointer. What it means in practice is that a value can only have <b>a single owner</b> at any given time. When you reassign a value to another variable the value is <b>moved</b> to the new variable and ownership transferred. If the value type implements the <code>Copy</code> trait the value will be copied to the new variable without any transferal of ownership. On the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors">Copy trait's documentation page</a> you can easily see what native types implement it. See the example below:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">foo</span> = <span style="color: #6ae4b9;">String</span>::from(<span style="color: #79a8ff;">"Hello!"</span>);
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">value is moved to `bar` here</span>
<span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">bar</span> = foo;

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Can't borrow `foo`s value here since it has been moved</span>
<span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"foo: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, foo);

<span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">x</span>: <span style="color: #6ae4b9;">usize</span> = 42;
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Since `usize` implements `Copy` the value is copied to</span>
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">`y` instead of moved</span>
<span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">y</span> = x;

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Which means that `x` can be safely borrowed by `println!()`</span>
<span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"x: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, x);
</pre>
</div>

<p>
What makes ownership so important is that it controls memory deallocation of the varible: the value is deallocated when its owner variable goes out of scope. In Rust terminology we say that the variable has been <i>dropped</i>. It enables automatic memory management without a garbage collector.
</p>

<p>
In the following example we hit a borrow after move error where we try and read the user input into <code>buffer</code>.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">fn</span> <span style="color: #feacd0;">main</span>() -&gt; <span style="color: #6ae4b9;">Result</span>&lt;(), <span style="color: #00bcff;">io</span>::<span style="color: #6ae4b9;">Error</span>&gt; {
    <span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">stdin</span> = <span style="color: #00bcff;">io</span>::stdin();
    <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">The String buffer is allocated outside of the `loop`</span>
    <span style="color: #b6a0ff;">let</span> <span style="color: #b6a0ff;">mut</span> <span style="color: #00d3d0;">buffer</span> = <span style="color: #6ae4b9;">String</span>::new();

    <span style="color: #b6a0ff;">loop</span> {
        <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Rock, paper or scissors?"</span>);
        <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Borrow after move occurs here...</span>
        stdin.read_line(&amp;<span style="color: #b6a0ff;">mut</span> buffer)<span style="color: #f78fe7; font-weight: bold;">?</span>;

        <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">...since the value was here in the previous iteration</span>
        <span style="color: #b6a0ff;">if</span> <span style="color: #b6a0ff;">let</span> <span style="color: #6ae4b9;">Ok</span>(shape) = <span style="color: #6ae4b9;">HandShape</span>::try_from(buffer) {
            <span style="color: #b6a0ff;">match</span> execute_round(shape, <span style="color: #6ae4b9;">HandShape</span>::<span style="color: #6ae4b9;">Paper</span>) {
                <span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">...</span>
            }
        } <span style="color: #b6a0ff;">else</span> {
            <span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"Sorry, I didn't quite get that..."</span>);
        }
    }

    <span style="color: #6ae4b9;">Ok</span>(())
}
</pre>
</div>

<p>
<b>EXERCISE 19:</b> Figure out a way to resolve the borrow-after-move error. (Spoiler alert below)
</p>

<p>
How can we solve this issue? A quick and dirty solution is to move the String allocation into the loop so we get a new one on every iteration. But let's say that we're all of sudden extremely concerned with the performance and memory footprint of our application and thus we don't want to allocate new String instances when we don't need to: how do we solve it then?
</p>

<p>
Why is the <code>buffer</code> String moved into <code>HandShape::try_from()</code>? Function parameters work just like variable assignments in that they take ownership of the value if its type does not implement the <code>Copy</code> trait. As we've seen in the example above <code>String</code> does not. However there's another option, <i>references</i>. References are prefixed with the <code>&amp;</code> operator.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">foo</span> = <span style="color: #6ae4b9;">String</span>::from(<span style="color: #79a8ff;">"Hello!"</span>);
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">`bar` is assigned to a reference of `foo`, so ownership is not</span>
<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">transferred.</span>
<span style="color: #b6a0ff;">let</span> <span style="color: #00d3d0;">bar</span> = &amp;foo;

<span style="color: #a8a8a8; font-style: italic;">// </span><span style="color: #a8a8a8; font-style: italic;">Which means this is fine!</span>
<span style="color: #f78fe7;">println!</span>(<span style="color: #79a8ff;">"foo: </span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">"</span>, foo);
</pre>
</div>

<p>
By using a reference we are not setting the variable to the actual value but a referential pointer to it, so ownership is not transferred. Creating a reference is called <i>borrowing</i> in Rust terminology. <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">This chapter in the Rust language book</a> explains references and borrowing in more detail.
</p>

<p>
<b>EXERCISE 20:</b> Change the <code>TryFrom&lt;String&gt;</code> implementation to <code>TryFrom&lt;&amp;String&gt;</code>.
</p>

<p>
The practice of taking references instead of values in function parameters is called pass-by-reference and should be preferred if possible to pass-by-value with which you can easily end up battling the Rust borrow checker.
</p>

<p>
There are more improvements we can do but we will leave it here for now. If you are interested even more idiomatic ways of solving the above issue you can have a look at <a href="https://github.com/iensu/janken/commit/3fa1267fc3f331e4e752fa35853e00b1fc244384">TryFrom&lt;&amp;str&gt; instead of TryFrom&lt;&amp;String&gt;</a> and <a href="https://github.com/iensu/janken/commit/78a54d4b74fa651c5faa518414992d731f967097">Implementing FromStr instead of TryFrom</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orga944c66" class="outline-3">
<h3 id="orga944c66"><span class="section-number-3">3.5.</span> Making it random</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Currently our adversary is just responding with the same hand shape everytime, not much fun at all. We need a way to make it respond with different shapes each time. Oddly enough Rust does not provide an easy way of generating random numbers in its standard library, so we will have to some foraging to find a suitable package on <a href="https://crates.io">https://crates.io</a>, Rust's crate registry.
</p>

<p>
Among the most popular crates we see <a href="https://crates.io/crates/rand">the rand crate</a> which is the go-to crate for all your randomization needs.
</p>

<p>
<b>EXERCISE 21:</b> Add <code>rand</code> as a dependency in Cargo.toml:
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #6ae4b9;">package</span>]
<span style="color: #00d3d0;">name</span> = <span style="color: #79a8ff;">"janken"</span>
<span style="color: #00d3d0;">version</span> = <span style="color: #79a8ff;">"0.1.0"</span>
<span style="color: #00d3d0;">edition</span> = <span style="color: #79a8ff;">"2021"</span>

[<span style="color: #6ae4b9;">dependencies</span>]
<span style="color: #00d3d0;">rand</span> = <span style="color: #79a8ff;">"0.8.4"</span>
</pre>
</div>

<p>
<b>EXERCISE 22:</b> Have a look at <a href="https://rust-random.github.io/book/guide-start.html">the rand documentation</a> and find a way to generate a random <code>HandShape</code>.
</p>

<p>
You did it! You have built a very simple, but functional, implementation of rock, paper, scissors in Rust. However, we have barely scratched the surface of what the Rust language has to offer, we haven't even touched upon <code>struct</code>:s, lifetimes or iterator patterns for instance. While there is still a lot more to discover, you should at least have gotten a sense of the Rust workflow and the language itself. Now it's up to you to either take your <i>janken</i> application to new heights, or find some other project to implement and learn more of Rust.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfff5c83" class="outline-2">
<h2 id="orgfff5c83"><span class="section-number-2">4.</span> Where to go next</h2>
<div class="outline-text-2" id="text-4">
<p>
If I managed to whet your appetite for more, here are a some great resources I found very useful when learning Rust:
</p>

<p>
<b>Getting started</b>
</p>
<ul class="org-ul">
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a></li>
<li><a href="https://github.com/rust-lang/rustlings/">The Rustlings course</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a></li>
<li><a href="https://www.youtube.com/c/RyanLevicksVideos/videos">Ryan Levick's Rust videos</a></li>
<li><a href="https://pragprog.com/titles/khrust/programming-webassembly-with-rust/">Programming WebAssembly with Rust</a></li>
</ul>

<p>
<b>Intermediate</b>
</p>
<ul class="org-ul">
<li><a href="https://doc.rust-lang.org/std/index.html">Standard library documentation</a></li>
<li><a href="https://www.zero2prod.com/index.html?country=Sweden&amp;discount_code=VAT20">Zero To Production in Rust</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust</a> (Video series by Jon Gjengset)</li>
</ul>

<p>
<b>Advanced</b>
</p>
<ul class="org-ul">
<li><a href="https://www.youtube.com/c/JonGjengset/featured">Jon Gjengset's other Rust videos</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jens Östlund</p>
<p class="date">Created: 2021-12-09 Thu 13:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
